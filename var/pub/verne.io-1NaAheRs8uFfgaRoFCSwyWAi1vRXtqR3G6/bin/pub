#!/usr/bin/env python

# TODO: https://www.python.org/dev/peps/pep-0302/.
# TODO: Single symlink deref. If can't find the address in the path, then
# perhaps it'll dereference to a path that has an address
# TODO: Don't sign the same branch twice

import argparse
import collections
import io
import itertools
import logging
import os
import os.path
import re
import sys

import pybitcointools
import pygit2

from verne.tree import Tree, Branch

log = logging.root


SIG_FILE = '.sig'
ERR_INVALID_FOLDER = ("Cannot publish %s. "
                      "Path must point to a folder with name {name}-{pubhash}, "
                      "where {pubhash} is a valid Satoshi address (type 1) "
                      "which you have the private key for.")
ERR_UNCOMMITTED = "Cannot publish %s. Folder has uncommitted changes."
RE_FOLDER = re.compile('^.*-[1][a-km-zA-HJ-NP-Z0-9]{26,33}$')
BRANCH_PREFIX = 'out/pub/'



def main():
    args = parser.parse_args()
    # For now, path is assumed to be relative to the root of the repository,
    # but this should change in the future.
    path = os.path.relpath(args.path)

    # Init repo
    repodir = pygit2.discover_repository('.')
    repo = pygit2.Repository(repodir)

    # Get pubkey hash
    name = args.path.rstrip().rstrip('/').rsplit('/', 1)[-1]
    addr = name.rsplit('-', 1)[-1]
    if not (os.path.isdir(args.path) and RE_FOLDER.match(name)):
        raise ValueError(ERR_INVALID_FOLDER % name)
    log.info("Folder to publish: %s", path)

    # Make sure user has no uncommitted changes in the path
    for (p, st) in repo.status().items():
        if p.startswith(path):
            if st not in (pygit2.GIT_STATUS_IGNORED,):
                print p
                for k in dir(pygit2):
                    if getattr(pygit2, k) == st:
                        print k
                raise ValueError(ERR_UNCOMMITTED % path)

    # Get PK
    privkey = os.environ.get('VERNE_PRIVKEY', '').strip()
    if privkey:
        if addr != pybitcointools.privkey_to_address(privkey):
            raise ValueError("Private key incorrect; cannot continue")
    while not privkey:
        privkey = raw_input("Please enter the private key for %s: " % addr)
        if addr != pybitcointools.privkey_to_address(privkey):
            log.error("Private key incorrect")
            continue

    # Validate
    # sig_path = os.path.join(path, SIG_FILE)
    # try:
    #     check_signed_branch(repo, sig_path, privkey, branch)
    # except NotSigned as e:
    #     if args.force:
    #         print "Overriding unsigned branch due to --force"
    #     else:
    #         raise
    
    # Need to know if there are any unsigned changes.
    # For now we will work on the principle that all
    # data in our working branch is kosher, since we
    # validate everything on merging.
    import pdb; pdb.set_trace()

    # Extract the desired subtree from the user's working copy
    tree = Tree(repo, repo.index.write_tree())
    tree = tree[path].wrap(path)

    # Make sure that the branch has actually changed
    if branch.exists and branch.head.tree == tree:
        log.info("Branch is up to date")
        return

    # Sign tree and commit
    tree_signed = sign_tree(repo, privkey, path, tree)
    commit = branch.commit("Sign " + path, tree_signed)
    log.info("Wrote to branch %s, commit id %s" % (branch_name, commit.oid.hex))
    # repo.index.merge(commit.id)


def sign_tree(repo, privkey, subpath, tree):
    signature = pybitcointools.ecdsa_sign(tree.oid.hex, privkey)
    return tree.set(subpath + '/' + SIG_FILE, signature)


def check_signed_branch(repo, sig_path, privkey, branch):
    if not branch.exists:
        return
    iter_revs = revisions(branch.head, sig_path)
    revs = list(itertools.islice(iter_revs, 2))
    if len(revs) == 0:
        raise NotSigned("Unsigned modifications found in %s" % branch.name)
    subpath = os.path.dirname(sig_path)
    tree = branch.head.tree.delete(sig_path)
    # To validate, we need to sign the tree with the previous signature.
    if len(revs) == 2:
        tree = tree.insert(sig_path, revs[1])
    signed_tree = tree[subpath].wrap(subpath)
    signature = pybitcointools.ecdsa_sign(signed_tree.hex, privkey)
    if signature != revs[0]:
        raise NotSigned("Bad signature. Expecting %s, got %s" %
            (revs[0], signature))



def revisions(commit, path, last=None):
    try:
        entry = commit.tree[path]
    except KeyError:
        return
    if entry != last:
        yield entry
        last = entry
    for parent in commit.parents:
        for rev in revisions(parent, path, last):
            yield rev


class NotSigned(ValueError):
    pass


parser = argparse.ArgumentParser(description='Verne Publish')
parser.add_argument('-f', '--force', action='store_true')
parser.add_argument('path')


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
