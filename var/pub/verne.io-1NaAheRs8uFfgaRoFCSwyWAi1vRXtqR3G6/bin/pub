#!/usr/bin/env python

# TODO: https://www.python.org/dev/peps/pep-0302/.
# TODO: Single symlink deref. If can't find the address in the path, then
# perhaps it'll dereference to a path that has an address
# TODO: Don't sign the same branch twice

import argparse
import collections
import io
import itertools
import logging
import os
import os.path
import re
import sys

import pybitcointools
import pygit2

log = logging.root


SIG_FILE = '.sig'
BRANCH_PREFIX = 'verne-pub/'
ERR_INVALID_FOLDER = ("Cannot publish %s. "
                      "Path must point to a folder with name {name}-{pubhash}, "
                      "where {pubhash} is a valid Satoshi address (type 1) "
                      "which you have the private key for.")
ERR_UNSTAGED = "Cannot publish %s. Folder has unstaged changes."
RE_FOLDER = re.compile('^.*-[1][a-km-zA-HJ-NP-Z0-9]{26,33}$')
GIT_UNSTAGED_STATII = (128, 256, 512)



def main():
    args = parser.parse_args()
    # For now, path is assumed to be relative to the root of the repository,
    # but this should change in the future.
    path = os.path.relpath(args.path)

    # Init repo
    repodir = pygit2.discover_repository('.')
    repo = pygit2.Repository(repodir)

    # Get pubkey hash
    name = args.path.rstrip().rstrip('/').rsplit('/', 1)[-1]
    addr = name.rsplit('-', 1)[-1]
    if not (os.path.isdir(args.path) and RE_FOLDER.match(name)):
        raise ValueError(ERR_INVALID_FOLDER % name)
    log.info("Folder to publish: %s", path)

    # Make sure user has no unstaged changes in the path
    for (p, st) in repo.status().items():
        if p.startswith(path) and st in GIT_UNSTAGED_STATII:
            raise ValueError(ERR_UNSTAGED % path)

    # Get the branch
    branch_name = BRANCH_PREFIX + name
    branch = repo.lookup_branch(branch_name)

    # Get PK
    privkey = os.environ.get('VERNE_PRIVKEY', '').strip()
    while not privkey:
        privkey = raw_input("Please enter the private key for %s: " % addr)
        if addr != pybitcointools.privkey_to_address(privkey.strip()):
            print "Private key incorrect"
            continue

    # Validate
    sig_path = os.path.join(path, SIG_FILE)
    try:
        check_signed_branch(repo, sig_path, privkey, branch)
    except NotSigned as e:
        if args.force:
            print "Overriding unsigned branch due to --force"
        else:
            raise


    # Extract the desired subtree from the user's working copy
    oid = repo.index.write_tree()
    entry = bottom_entry = repo.get(oid)[path]
    for component in reversed(path.split('/')):
        builder = repo.TreeBuilder()
        builder.insert(component, entry.oid, pygit2.GIT_FILEMODE_TREE)
        entry = repo.get(builder.write())
    tree = repo.get(entry.oid)

    # Make sure that the branch has actually changed
    if branch and branch.get_object().tree.hex == tree.hex:
        log.info("Branch is up to date")
        return

    # Sign tree
    tree_signed = sign_tree(repo, privkey, path, tree)

    # Commit new history
    author = pygit2.Signature(addr, addr + '@authors.tld')
    committer = pygit2.Signature(sys.argv[0] + '@', 'vdsm@verne.io')

    branch = repo.lookup_branch(branch_name)
    ref_name = branch.name if branch else None

    parents = []
    if branch:
        parents = [branch.get_object().oid]

    commit_oid = repo.create_commit(ref_name, author, committer, '',
                                    tree_signed.oid, parents)
    commit = repo.get(commit_oid)

    if not branch:
        branch = repo.create_branch(branch_name, commit)



def sign_tree(repo, privkey, subpath, tree):
    signature = pybitcointools.ecdsa_sign(tree.oid.hex, privkey)
    sig_oid = repo.create_blob(signature)
    subtree = repo.get(tree[subpath].oid)  # TODO: Validate entry type
    builder = repo.TreeBuilder(subtree)
    builder.insert(SIG_FILE, sig_oid, pygit2.GIT_FILEMODE_BLOB)
    entry = repo.get(builder.write())
    entry = wrap_tree(repo, subpath, entry)
    return repo.get(entry.oid)


def wrap_tree(repo, subpath, thing):
    for component in reversed(subpath.split('/')):
        builder = repo.TreeBuilder()
        builder.insert(component, thing.oid, pygit2.GIT_FILEMODE_TREE)
        thing = repo.get(builder.write())
    return thing


def check_signed_branch(repo, sig_path, privkey, branch):
    iter_revs = revisions(branch.get_object(), sig_path)
    revs = list(itertools.islice(iter_revs, 2))
    tree = branch.get_object().tree
    if len(revs) == 0:
        raise NotSigned("Unsigned modifications found in %s" % branch.name)
    subpath = os.path.dirname(sig_path)
    subtree = repo.get(tree[subpath].oid)
    builder = repo.TreeBuilder(subtree)
    builder.remove(SIG_FILE)
    if len(revs) == 2:
        # Insert old sigfile
        blob_id = repo.get(revs[1].oid).oid
        builder.insert(SIG_FILE, blob_id, pygit2.GIT_FILEMODE_BLOB)
    subtree = repo.get(builder.write())
    signed_tree = wrap_tree(repo, subpath, subtree)
    signature = pybitcointools.ecdsa_sign(signed_tree.hex, privkey)
    if signature != repo.get(revs[0].oid).data:
        raise NotSigned("Bad signature. Expecting %s, got %s" %
            (repo.get(revs[0].oid).data, signature))



def revisions(commit, file, last=None):
    try:
        entry = commit.tree[file]
    except KeyError:
        return
    if entry != last:
        yield entry
        last = entry
    for parent in commit.parents:
        for rev in revisions(parent, file, last):
            yield rev


class NotSigned(ValueError):
    pass


parser = argparse.ArgumentParser(description='Verne Publish')
parser.add_argument('-f', '--force', action='store_true')
parser.add_argument('path')


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
